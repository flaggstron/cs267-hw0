<!DOCTYPE html>
<html>
<head>
  <title>cs267/hw0</title>
   <link href="/bootstrap-3.3.2-dist/css/bootstrap.css" rel="stylesheet">
   <link href="jumbotron-narrow.css" rel="stylesheet">
</head>
<body>

<h1>Gokul Ramesh</h1>
<h3>gr(at)berkeley.edu</h3>

 <h2>About me</h2>

 <p>I am currently a second-semester third-year undergraduate student. I joined my undergrad with an interest in signal-processing, stemming from my love of electronic music and synthesis. I spent a lot of time in high school creating instruments by blending oscillators, applying filters, and distorting waves. This interest brought me into EE, and after a few semester, I discovered my interests lie more in the CS aspect of generation, as there wasn't much innovation that still needed to be done.</p>

<p>My interest parallel computing stems from the raw concept itself, rather than any application; watching something (anything) crank out a few more FLOPS and run a bit faster gives me the satisfaction, and whether this is done through more efficient algorithms or through more compute power. For example, if you want high-definition real-time digital synthesis, some instruments require multiple cores simply to process the values (you have 44 thousand values a second, which takes a lot of computation). Seeing as large scale computing is going to be the future, I want to make sure I get a head start into the technology.</p>

<h2>Application - AI</h2>
<p>During winter 2014-15 one of the largest projects I worked on was helping develop an efficient AI for the digital collectible card game Hearthstone [1], created by Blizzard Entertainment. Being a card game, the entire process was difficult to code, let alone optimize. Luckily, most of the frame work was already built (detecting cards, applying moves) so all I worked on was the decision process and optimizing moves.</p>

<p>At a very basic level, the game involved looking at the different cards in your hand, and playing them in the various different orders. However in order to step up the competitiveness of the bot, the project also takes the next step of predicting possible plays by the opponent. Based on possible plays, the bot (tries to) deterministically find the optimal move, by looking ahead a few more turns. Depending on the compute speed of the computer, more moves can be predicted, and with enough power the entire game of a quick deck can be mapped out.</p>

<p>The main bottleneck in this process was to calculate the optimal move in the 90 seconds you get for the turn. Initially the code was a BFS with a number that determines what the value of the state is. This found the optimal move, but it was way to slow. Even after running it on multiple cores, there wasn't much further improvement. Instead, we optimized choosing a “good” move, rather than the best move, using BFS as long as we could be deterministic (for our play) and then doing DFS on the best moves with worst case scenario plays from the opponent. This minimized damage while maximizing success.</p>

<p>In essence, the problem being solved is just a game tree. The code was run on a single computer with as many threads as we could get, usually 6 threads on a dedicated gaming machine. The majority of the code base was written in C#, so when I joined I had to learn how C# threads worked, as OpenMP didn't work out of the box. The theory was more or less the same as OpenMP, so I could figure out how to load balance and implement it pretty easily. There was no benchmark to test how many FLOPS we were achieving, but the bot went from a 35-45% win rate in casual play to a ~70% win rate, due to the increased depth of calculation. </p>

<p>The project has been put in stealth mode since Blizzard Entertainment has been banning anyone who uses add-ons to the game, so the git repository is not public. However, an older version[2] of it is, which is receiving occasional mechanics updates.</p>
<h2>References</h2>
<a href="http://us.battle.net/hearthstone/en/">[1] http://us.battle.net/hearthstone/en/ </a><br>
<a href="https://github.com/noHero123/silverfish">[2] https://github.com/noHero123/silverfish</a>

</body>

</html>

